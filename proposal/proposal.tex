\documentclass[11pt,twoside]{article}
\usepackage[authoryear,semicolon]{natbib}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{textgreek}
\usepackage[color=yellow]{todonotes}
\setlength{\marginparwidth}{1.25in}
\usepackage{xifthen}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{proof}
\usepackage{colonequals}
\usepackage{comment}
\usepackage{textcomp}
\usepackage[us]{optional}
\usepackage{color}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphics}
\usepackage{mathpartir}
\usepackage{import}
\usepackage{stackengine}
\usepackage{scalerel}
\usepackage{xcolor}
\bibliographystyle{ACM-Reference-Format}

\begin{document}
\title{CIS 670 Project Proposal}
\author{Paul He, Irene Yoon}
\date{Spring 2021}

\maketitle{}


\section{Project Goal}
In this project, we aim to encode a unary logical relation for the call-by-push-
value (CBPV) calculus in the Iris proof framework. CBPV is a nifty calculus that
subsumes both call-by-value (CBV) and call-by-name (CBN). The scope of this project
will define a unary semantic typing relation on a basic CBPV calculus. The reason
that we choose the Iris framework for this purpose is because we view this project
as necessary groundwork for an exploration of an equational theory of a CBPV
calculus with recursive types. 

\section{Introduction} 

\textbf{Formalized Logical Relations of CBPV}
This is primarily inspired by the pioneering work of 
~\cite{rizkallah} of an formalized equational theory of CBPV, which formalizes the
soundness of the equational theory with relation to an obesrvational equivalence.
~\cite{forster}'s approach offers a slightly different proof setup: they formalize 
contexts as first-class objects using a Kripke semantics.
We wish to develop a formalization similar to ~\cite{forster} because the Iris
framework offers a natural leverage to Kripke-semantic logical relations.\\
\\
\textbf{Iris Proof Framework}
The Iris proof framework is a state-of-the-art tool that has a rich program logic 
that can be used for reasoning about concurrent programs. 
We plan to use its underlying logic, which is based on a 
step-indexed logical relation, to define a logical relation on CBPV.
Iris's base logic is equipped with modalities that make this definition easier,
especially under the presence of recursive types.
A similar approach is ~\cite{timany}'s work on defining a logical relation for 
the state monad, where their relation induces a definition of contextual 
equivalence on effectful computations encapsulated by the ST monad.

\section{CBPV Calculus}
In this section, we present the CBPV calculus that we wish
to formalize, which is based on the calculus of ~\cite{forster}. 

\newcommand{\sep}{\;|\;}

\begin{figure}[tp]
    \begin{minipage}{.4\textwidth}
        \begin{align*}
        \mathit{value \; types} &\;\;
            A &&::=&& U \; \underline{C} \sep 0 \sep 1 \sep A_1 \times A_2 \sep A_1 + A_1 \\
        \mathit{computation \; types} &\;\; \underline{C} &&::=&& F \; A \sep A \rightarrow \underline{C} \sep \top \sep \underline{C_1} \; \& \; \underline{C_2}\\
        \mathit{environments} &\;\; \Gamma &&::=&& x_1 : A_1, ..., x_n : A_n
        \end{align*}
    \end{minipage}
    \\
    \begin{minipage}{.4\textwidth}
        \begin{align*}
        \mathit{value \; terms} &\;\;
            V &&::=&& \mathsf{thunk} \; M \sep x \sep () \sep (V_1, \, V_2) \sep \mathsf{inj}_i \; V \\
        \mathit{computation \; terms} &\;\; M &&::=&& 
            * \sep \mathsf{return} \; V \sep \lambda x.M \sep M \; V \sep \langle M_1, M_2 \rangle \sep 
            \mathsf{force} \; V \sep \mathsf{case}(V, \, x.M_1, \, x.M_2) \\
            &&&&& \mathsf{let} \; x \leftarrow M \; \mathsf{in} \; N \sep \mathsf{prj}_i \; M
        \end{align*}
    \end{minipage}%
    \\ \\

    \footnotesize{\textbf{Value Typing}} \fbox{$\Gamma \vdash^V V : A$}

    \begin{mathpar}
      \inferrule[var]
      {(x : A) \in \Gamma}
      {\Gamma\vdash^V x : A}

      \inferrule[unit]
      {\strut}
      {\Gamma\vdash^V () : 1}

      \inferrule[prod]
      {\Gamma \vdash V_1 : A_1 \; \Gamma \vdash V_2 : A_2}
      {\Gamma\vdash^V (V_1, \, V_2) : A_1 \times A_2}

      \inferrule[sum]
      {\Gamma \vdash V : A_i}
      {\Gamma\vdash^V \mathsf{inj}_i \; V : A_1 + A_2}

      \inferrule[thunk]
      {\Gamma \vdash M : \underline{C}}
      {\Gamma\vdash^V \mathsf{thunk} \; V : U \; \underline{C}}
    \end{mathpar}

    \footnotesize{\textbf{Computation Typing}} \fbox{$\Gamma \vdash^C M : C$}

    \begin{mathpar}
    \end{mathpar}

  
    \caption{CBPV Syntax and Statics}
    \label{fig:statics}
  
  \end{figure}

\bibliography{refs}

\end{document}
