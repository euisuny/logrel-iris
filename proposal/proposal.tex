\documentclass[11pt,twoside]{article}
\usepackage[authoryear,semicolon]{natbib}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{textgreek}
\usepackage[color=yellow]{todonotes}
\setlength{\marginparwidth}{1.25in}
\usepackage{xifthen}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{proof}
\usepackage{colonequals}
\usepackage{comment}
\usepackage{textcomp}
\usepackage[us]{optional}
\usepackage{color}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphics}
\usepackage{mathpartir}
\usepackage{import}
\usepackage{stackengine}
\usepackage{scalerel}
\usepackage{xcolor}
\bibliographystyle{ACM-Reference-Format}

\begin{document}
\title{CIS 670 Project Proposal}
\author{Paul He, Irene Yoon}
\date{Spring 2021}

\maketitle{}

\section{Project Goal}
In this project, we aim to perform logical relations proofs for the call-by-push-value (CBPV) calculus in the Iris proof framework.
CBPV is a nifty calculus that subsumes both call-by-value (CBV) and call-by-name (CBN) while.
This project will define a unary semantic typing relation on a basic CBPV calculus.
The Iris framework provides support for step-indexed logical relations to model recursion.
We view this direction as necessary groundwork for exploring equational theories of CBPV calculi with recursive types.

\section{Introduction}

Our first step will be to define semantic typing for CBPV without recursive types.
This will require us to learn more about Iris and using the Iris proof mode in Coq to define logical relations in the Iris logic.
Once this is done, we can extend our language and logical relations to add recursive types.
At this point, the support for step-indexing in Iris should simplify our definitions compared to manual step-indexing.
Time permitting, we can also extend to more complex logical relations such as binary relations for contexual equivalence.
Another possible future direction is to extend our language with more features that are well-suited to the features of Iris, such as higher order state or concurrency. \\

\textbf{Formalized Logical Relations of CBPV}
This is primarily inspired by the pioneering work of \citet{rizkallah} of a formalized equational theory of CBPV, which formalizes the soundness of the equational theory with respect to an observational equivalence.
\citet{forster}'s approach offers a slightly different proof setup: they formalize contexts as first-class objects using a Kripke semantics.
We wish to develop a formalization similar to \citet{forster} because the Iris framework offers a natural bridge to building Kripke logical relations.\\
\\
\textbf{Iris Proof Framework}
The Iris proof framework is a state-of-the-art tool that has a rich program logic that can be used for reasoning about concurrent programs.
We plan to use its underlying step-indexed logic to define logical relations for CBPV.
Iris's base logic is equipped with modalities that make such definition easier, especially in the presence of recursive types.
\citet{krebbers2017} presents a semantic typing result like the one we plan to do for a similar calculus with recursive types.
Another similar approach is \citet{timany}'s work on defining a logical relation for the state monad, where their relation induces a definition of contextual equivalence on effectful computations encapsulated by the ST monad.

\section{CBPV Calculus}
In this section, we present the CBPV calculus that we wish to formalize, which is based on the calculus of \citet{forster}.

\newcommand{\sep}{\;|\;}

\begin{figure}[tp]
    \begin{minipage}{.4\textwidth}
        \begin{align*}
        \mathit{value \; types} &\;\;
            A &&::=&& U \; \underline{C} \sep 0 \sep 1 \sep A_1 \times A_2 \sep A_1 + A_1 \\
        \mathit{computation \; types} &\;\; \underline{C} &&::=&& F \; A \sep A \rightarrow \underline{C} \sep \top \sep \underline{C_1} \; \& \; \underline{C_2}\\
        \mathit{environments} &\;\; \Gamma &&::=&& x_1 : A_1, ..., x_n : A_n
        \end{align*}
    \end{minipage}
    \\
    \begin{minipage}{.4\textwidth}
        \begin{align*}
        \mathit{value \; terms} &\;\;
            V &&::=&& \mathsf{thunk} \; M \sep x \sep () \sep (V_1, \, V_2) \sep \mathsf{inj}_i \; V \\
        \mathit{computation \; terms} &\;\; M &&::=&&
            * \sep \mathsf{return} \; V \sep \lambda x.M \sep M \; V \sep \langle M_1, M_2 \rangle \sep
            \mathsf{force} \; V \sep \mathsf{case}(V, \, x.M_1, \, x.M_2) \\
            &&&&& \mathsf{let} \; x \leftarrow M \; \mathsf{in} \; N \sep \mathsf{prj}_i \; M
        \end{align*}
    \end{minipage}%
    \\ \\

    \footnotesize{\textbf{Value Typing}} \fbox{$\Gamma \vdash^V V : A$}

    \begin{mathpar}
      \inferrule[var]
      {(x : A) \in \Gamma}
      {\Gamma\vdash^V x : A}

      \inferrule[unit]
      {\strut}
      {\Gamma\vdash^V () : 1}

      \inferrule[prod]
      {\Gamma \vdash V_1 : A_1 \; \Gamma \vdash V_2 : A_2}
      {\Gamma\vdash^V (V_1, \, V_2) : A_1 \times A_2}

      \inferrule[sum]
      {\Gamma \vdash V : A_i}
      {\Gamma\vdash^V \mathsf{inj}_i \; V : A_1 + A_2}

      \inferrule[thunk]
      {\Gamma \vdash M : \underline{C}}
      {\Gamma\vdash^V \mathsf{thunk} \; V : U \; \underline{C}}
    \end{mathpar}

    \footnotesize{\textbf{Computation Typing}} \fbox{$\Gamma \vdash^C M : C$}

    \begin{mathpar}
    \end{mathpar}


    \caption{CBPV Syntax and Statics}
    \label{fig:statics}

  \end{figure}

\bibliography{refs}

\end{document}
